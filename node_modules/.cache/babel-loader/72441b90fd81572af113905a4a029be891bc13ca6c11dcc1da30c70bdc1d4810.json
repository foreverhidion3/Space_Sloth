{"ast":null,"code":"//Bouncing and More...\nimport React,{useState,useEffect,useRef}from'react';import'./Dancing.css';import monkey_no_background_img from'../Images/Space_Sloth_nbg.svg';import banana_img from'../Images/note.webp';import GoBananas from'./GO_BANANAS';//Use debounce technique to handle double banana issue. Use it with new state const [isAddingBanana, setIsAddingBanana] = useState(false); \n//use debounce right before the return\n//debounce will also prevent banana-spaming aka \"going bananas\"\nimport{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const useDebounce=(callback,delay)=>{//Create a reference to store the timer ID for the debounce\nconst timeoutRef=useRef(null);//Return a new debounced function that wraps the original callback\nreturn function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}//Clear the previous timer (if any) whenever the debounced function is called\nclearTimeout(timeoutRef.current);//Start a new timer using the setTimeout function\n//The timer will execute the callback after the specified delay\ntimeoutRef.current=setTimeout(()=>{//Invoke the original callback with the provided arguments\ncallback(...args);},delay);};};const Dancing=()=>{//set states\nconst[monkey,setMonkey]=useState({x:100,y:20});const monkeySpeed=.1;const[driftDirection,setDriftDirection]=useState({x:1,y:1});const[xDirection,setXDirection]=useState(1);const[yDirection,setYDirection]=useState(1);const[injured,setInjured]=useState(false);const[injuredX,setInjuredX]=useState(0);const[injuredY,setInjuredY]=useState(0);const[bananas,setBananas]=useState([]);//Declare showBananas state\nconst[showBananas,setShowBananas]=useState(false);//New state to track adding banana status\nconst[isAddingBanana,setIsAddingBanana]=useState(false);//React handles state updates asynchronously. When the addBanana function is called, it updates the bananas state by appending a new banana to the existing array of bananas. However, if the state update for bananas is not completed before the next addBanana function is called, it can result in adding two bananas in quick succession.\n//This can happen because React batches state updates to improve performance. If multiple state updates are triggered within the same event loop, React batches them together and performs the updates in one go. However, if the bananas state update from the first addBanana function is not yet complete when the next addBanana function is called, it will be using the old state of bananas, leading to the addition of two bananas.\n//By introducing the isAddingBanana variable and the necessary checks, we can control the timing of adding bananas and ensure that a new banana is added only after the previous one has finished bouncing. This will prevent the issue of adding two bananas at a time.\n//However, don't forget, even with this new state I will have to add the debounce technique.\n//Go bananas\nconst[showClearButton,setShowClearButton]=useState(false);const containerRef=useRef(null);const animationFrameMonkeyRef=useRef(null);const monkeyRef=useRef(null);//Add bananaRef\nconst bananaRef=useRef(null);//Add animationFrameBananaRef \nconst animationFrameBananaRef=useRef(null);//GO BANANAS\nconst handleGoBananasClick=()=>{//Remove all the bananas and the monkey from the array\nsetBananas([]);setShowBananas(false);//Add the spinning monkey to the array\nsetBananas(prevBananas=>[...prevBananas,{x:10,//Initial position of the spinning monkey\ny:200,xDirection:1,yDirection:1,isSpinning:true//Add a flag to identify the spinning monkey\n}]);//Generate 100 bouncing bananas and add them to the array\nfor(let i=0;i<100;i++){const initialXDirection=Math.random()<0.5?1:-1;const initialYDirection=Math.random()<0.5?1:-1;setBananas(prevBananas=>[...prevBananas,{x:Math.random()*window.innerWidth,y:Math.random()*window.innerHeight,xDirection:initialXDirection,yDirection:initialYDirection}]);}setShowBananas(true);setShowClearButton(true);// Show the \"Clear Bananas\" button after generating bananas\n// Update the \"showBananas\" state to true\nsetShowBananas(true);};//clear banana madness\nconst handleClearBananasClick=()=>{setBananas([]);setShowBananas(false);//Set showClearButton to false after clearing the bananas\nsetShowClearButton(false);};//add banana\nconst addBanana=(x,y)=>{if(!isAddingBanana&&bananas.length<100){// Generate random initial direction for the banana\nconst initialXDirection=Math.random()<0.5?1:-1;const initialYDirection=Math.random()<0.5?1:-1;//set the starting position of the banana relative to the monkey\n//Half of the monkey's width\nconst bananaStartX=x+monkeyRef.current.width/4;//Half of the monkey's height\n//Does this look good at all sizes? \nconst bananaStartY=y+monkeyRef.current.height/2;setBananas(prevBananas=>[...prevBananas,{x:bananaStartX,y:bananaStartY,xDirection:initialXDirection,yDirection:initialYDirection}]);setShowBananas(true);}};//animate monkey\nuseEffect(()=>{const moveMonkey=()=>{const containerWidth=containerRef.current.clientWidth;const containerHeight=containerRef.current.clientHeight;const monkeyWidth=monkeyRef.current.width;const monkeyHeight=monkeyRef.current.height;setMonkey(prevPosition=>{let newX=prevPosition.x+driftDirection.x*monkeySpeed;let newY=prevPosition.y+driftDirection.y*monkeySpeed;let newDriftDirection={...driftDirection};if(newX>=containerWidth-monkeyWidth||newX<=0){newDriftDirection.x*=-1;// Reverse X direction\nnewX=Math.max(0,Math.min(containerWidth-monkeyWidth,newX));}if(newY>=containerHeight-monkeyHeight||newY<=0){newDriftDirection.y*=-1;// Reverse Y direction\nnewY=Math.max(0,Math.min(containerHeight-monkeyHeight,newY));}setDriftDirection(newDriftDirection);// Update the drift direction\nreturn{x:newX,y:newY};});animationFrameMonkeyRef.current=requestAnimationFrame(moveMonkey);};animationFrameMonkeyRef.current=requestAnimationFrame(moveMonkey);return()=>cancelAnimationFrame(animationFrameMonkeyRef.current);},[driftDirection,monkeySpeed,setMonkey,containerRef]);//animate banana\nuseEffect(()=>{//console.log for bananas array\nconsole.log(\"Bananas:\",bananas);const animateBananas=()=>{const containerWidth=containerRef.current.clientWidth;const containerHeight=containerRef.current.clientHeight;const bananaWidth=bananaRef.current.width;const bananaHeight=bananaRef.current.height;const bananaSpeed=.2;setBananas(prevBananas=>prevBananas.map(banana=>({...banana,x:banana.x+banana.xDirection*bananaSpeed,y:banana.y+banana.yDirection*bananaSpeed,xDirection:banana.x+banana.xDirection*bananaSpeed>=containerWidth-bananaWidth||banana.x+banana.xDirection*bananaSpeed<=0?banana.xDirection*-1:banana.xDirection,yDirection:banana.y+banana.yDirection*bananaSpeed>=containerHeight-bananaHeight||banana.y+banana.yDirection*bananaSpeed<=0?banana.yDirection*-1:banana.yDirection})));animationFrameBananaRef.current=requestAnimationFrame(animateBananas);};if(showBananas&&bananas.length>0){animationFrameBananaRef.current=requestAnimationFrame(animateBananas);}return()=>cancelAnimationFrame(animationFrameBananaRef.current);},[showBananas,bananas]);//is injured? drop banana\nuseEffect(()=>{//console.log for isAddingBanana state\nconsole.log(\"Is Adding Banana:\",isAddingBanana);if(injured){setShowBananas(true);const resetInjured=setTimeout(()=>{setInjured(false);//Reset adding banana status \nsetIsAddingBanana(false);//Add banana near the monkey when it gets injured \naddBanana(injuredX,injuredY);//Delay in milliseconds before resetting injured state \n},500);return()=>clearTimeout(resetInjured);}else{//Reset adding banana status when the monkey is not injured\nsetIsAddingBanana(false);}},[injured,injuredX,injuredY]);//debounce to use later\nconst addBananaWithDebounce=useDebounce(addBanana,500);return/*#__PURE__*/_jsx(\"div\",{className:\"page_body\",children:/*#__PURE__*/_jsxs(\"div\",{className:\"dancing_monkey_container\",ref:containerRef,children:[/*#__PURE__*/_jsx(GoBananas,{onGoBananasClick:handleGoBananasClick,showClearButton:showClearButton,onClearBananasClick:handleClearBananasClick}),showBananas&&bananas.map((banana,index)=>/*#__PURE__*/_jsx(\"img\",{src:banana_img,alt:\"banana\",className:\"banana_img\",style:{transform:\"translate(\".concat(banana.x,\"px, \").concat(banana.y,\"px)\")},ref:bananaRef},index)),/*#__PURE__*/_jsx(\"img\",{ref:monkeyRef,src:monkey_no_background_img,alt:\"dancing_monkey\",id:\"dancing_monkey_img\",className:injured?'injured_monkey':'',style:{transform:\"translate(\".concat(monkey.x,\"px, \").concat(monkey.y,\"px)\")},onClick:()=>{if(bananas.length<10&&!isAddingBanana){setInjured(true);setInjuredX(monkey.x);setInjuredY(monkey.y);setIsAddingBanana(true);addBananaWithDebounce(monkey.x,monkey.y);}}})]})});};export default Dancing;// //Monkey is bouncing and only bouncing\n// import React, { useState, useEffect, useRef } from 'react';\n// import './Dancing.css';\n// import monkey_no_background_img from '../../images/Space_Monkey_No_Background.svg';\n// const Dancing = () => {\n//   const [x, setX] = useState(10);\n//   const [y, setY] = useState(200);\n//   const [xDirection, setXDirection] = useState(1);\n//   const [yDirection, setYDirection] = useState(1);\n//   const imageRef = useRef(null);\n//   const containerRef = useRef(null);\n//   const animationFrameRef = useRef(null);\n//   useEffect(() => {\n//     const animate = () => {\n//       const containerWidth = containerRef.current.clientWidth;\n//       const containerHeight = containerRef.current.clientHeight;\n//       const monkeyWidth = imageRef.current.width;\n//       const monkeyHeight = imageRef.current.height;\n//       const speed = .4; \n//       console.log('x:', x);\n//       console.log('y:', y);\n//       console.log('xDirection:', xDirection);\n//       console.log('yDirection:', yDirection);\n//       setX((prevX) => {\n//         const nextX = prevX + xDirection * speed;\n//         if (nextX >= containerWidth - monkeyWidth || nextX <= 0) {\n//           setXDirection((prevDirection) => prevDirection * -1);\n//         }\n//         return nextX;\n//       });\n//       setY((prevY) => {\n//         const nextY = prevY + yDirection * speed;\n//         if (nextY >= containerHeight - monkeyHeight || nextY <= 0) {\n//           setYDirection((prevDirection) => prevDirection * -1);\n//         }\n//         return nextY;\n//       });\n//       animationFrameRef.current = requestAnimationFrame(animate);\n//     };\n//     // Start the animation loop on mount\n//     animationFrameRef.current = requestAnimationFrame(animate);\n//     // Clean up the animation frame when unmount\n//     return () => cancelAnimationFrame(animationFrameRef.current);\n//   }, [x, y, xDirection, yDirection]);\n//   return (\n//     <div className='page_body'>\n//       <div className='dancing_monkey_container' ref={containerRef}>\n//         <img\n//           ref={imageRef}\n//           src={monkey_no_background_img}\n//           alt='dancing_monkey'\n//           id='dancing_monkey_img'\n//           style={{ transform: `translate(${x}px, ${y}px)` }}\n//         />\n//       </div>\n//     </div>\n//   );\n// };\n// export default Dancing;\n//Monkey is Bouncing\n// import React, { useState, useEffect, useRef } from 'react';\n// import './Dancing.css';\n// import monkey_no_background_img from '../../images/Space_Monkey_No_Background.svg';\n// const Dancing = () => {\n//   const [x, setX] = useState(0);\n//   const [y, setY] = useState(0);\n//   const [xDirection, setXDirection] = useState(1);\n//   const [yDirection, setYDirection] = useState(1);\n//   const imageRef = useRef(null);\n//   const containerRef = useRef(null);\n//   const animationFrameRef = useRef(null);\n//   useEffect(() => {\n//     const animate = () => {\n//       const containerWidth = containerRef.current.clientWidth;\n//       const containerHeight = containerRef.current.clientHeight;\n//       const monkeyWidth = imageRef.current.width;\n//       const monkeyHeight = imageRef.current.height;\n//       const speed = 2; // Adjust the speed for smoother motion\n//       console.log('x:', x);\n//       console.log('y:', y);\n//       console.log('xDirection:', xDirection);\n//       console.log('yDirection:', yDirection);\n//       setX((prevX) => {\n//         const nextX = prevX + xDirection * speed;\n//         if (nextX >= containerWidth - monkeyWidth || nextX <= 0) {\n//           setXDirection((prevDirection) => prevDirection * -1);\n//         }\n//         return nextX;\n//       });\n//       setY((prevY) => {\n//         const nextY = prevY + yDirection * speed;\n//         if (nextY >= containerHeight - monkeyHeight || nextY <= 0) {\n//           setYDirection((prevDirection) => prevDirection * -1);\n//         }\n//         return nextY;\n//       });\n//       animationFrameRef.current = requestAnimationFrame(animate);\n//     };\n//     // Start the animation loop on mount\n//     animationFrameRef.current = requestAnimationFrame(animate);\n//     // Clean up the animation frame when unmount\n//     return () => cancelAnimationFrame(animationFrameRef.current);\n//   }, [x, y, xDirection, yDirection]);\n//   return (\n//     <div className='page_body'>\n//       <div className='dancing_monkey_container' ref={containerRef}>\n//         <img\n//           ref={imageRef}\n//           src={monkey_no_background_img}\n//           alt='dancing_monkey'\n//           id='dancing_monkey_img'\n//           style={{ transform: `translate(${x}px, ${y}px)` }}\n//         />\n//       </div>\n//     </div>\n//   );\n// };\n// export default Dancing;\n// ok, now the monkeytravels to the bottom of the container...then, he moves to the right util he exists the container and disappears...please fix that so that the monkey bounces around the container.\n// import React, { useState, useEffect, useRef } from 'react';\n// import './Dancing.css';\n// import monkey_no_background_img from '../images/Space_Monkey_No_Background.png';\n// const Dancing = () => {\n//   const [x, setX] = useState(0);\n//   const [y, setY] = useState(0);\n//   const [xDirection, setXDirection] = useState(1);\n//   const [yDirection, setYDirection] = useState(1);\n//   const imageRef = useRef(null);\n//   const containerRef = useRef(null);\n//   useEffect(() => {\n//     const animate = () => {\n//       const containerWidth = containerRef.current.clientWidth;\n//       const containerHeight = containerRef.current.clientHeight;\n//       const monkeyWidth = imageRef.current.width;\n//       const monkeyHeight = imageRef.current.height;\n//       const speed = 1.5; // Adjust the speed for smoother motion\n//       setX((prevX) => {\n//         const nextX = prevX + xDirection * speed;\n//         if (nextX >= containerWidth - monkeyWidth || nextX <= 0) {\n//           setXDirection((prevDirection) => prevDirection * -1);\n//         }\n//         return nextX;\n//       });\n//       setY((prevY) => {\n//         const nextY = prevY + yDirection * speed;\n//         if (nextY >= containerHeight - monkeyHeight || nextY <= 0) {\n//           setYDirection((prevDirection) => prevDirection * -1);\n//         }\n//         return nextY;\n//       });\n//       requestAnimationFrame(animate);\n//     };\n//     // Start the animation loop when the component mounts\n//     const animationFrame = requestAnimationFrame(animate);\n//     // Clean up the animation frame when the component unmounts\n//     return () => cancelAnimationFrame(animationFrame);\n//   }, [xDirection, yDirection]);\n//   return (\n//     <div className='page_body'>\n//       <div className='dancing_monkey_container' ref={containerRef}>\n//         <img\n//           ref={imageRef}\n//           src={monkey_no_background_img}\n//           alt='dancing_monkey'\n//           id='dancing_monkey_img'\n//           style={{ transform: `translate(${x}px, ${y}px)` }}\n//         />\n//       </div>\n//     </div>\n//   );\n// };\n// export default Dancing;\n// One direction animation\n// import React, { useEffect, useState, useRef } from 'react';\n// import './Dancing.css';\n// import monkey_no_background_img from '../images/Space_Monkey_No_Background.png';\n// const Dancing = () => {\n//   const [x, setX] = useState(0);\n//   const [y, setY] = useState(0);\n//   const [xDirection, setXDirection] = useState(1);\n//   const [yDirection, setYDirection] = useState(1);\n//   const imageRef = useRef(null);\n//   const containerRef = useRef(null); // Reference to the container element\n//   const animate = () => {\n//     const containerWidth = containerRef.current.clientWidth;\n//     const containerHeight = containerRef.current.clientHeight;\n//     const monkeyWidth = imageRef.current.width;\n//     const monkeyHeight = imageRef.current.height;\n//     const speed = 1.5; // Adjust the speed for smoother motion\n//     const damping = 0.8; // Adjust the damping for smoother bouncing\n//     setX((prevX) => {\n//       let nextX = prevX + xDirection * speed;\n//       if (nextX >= containerWidth - monkeyWidth || nextX <= 0) {\n//         setXDirection((prevDirection) => prevDirection * -1 * damping);\n//         nextX = prevX + xDirection * speed * damping;\n//       }\n//       return Math.max(0, Math.min(nextX, containerWidth - monkeyWidth));\n//     });\n//     setY((prevY) => {\n//       let nextY = prevY + yDirection * speed;\n//       if (nextY >= containerHeight - monkeyHeight || nextY <= 0) {\n//         setYDirection((prevDirection) => prevDirection * -1 * damping);\n//         nextY = prevY + yDirection * speed * damping;\n//       }\n//       return Math.max(0, Math.min(nextY, containerHeight - monkeyHeight));\n//     });\n//     requestAnimationFrame(animate);\n//   };\n//   // Start the animation loop when the component mounts\n//   useEffect(() => {\n//     requestAnimationFrame(animate);\n//   }, []);\n//   return (\n//     <div className='page_body'>\n//       <div className='dancing_monkey_container' ref={containerRef}>\n//         <img\n//           ref={imageRef}\n//           src={monkey_no_background_img}\n//           alt='dancing_monkey'\n//           id='dancing_monkey_img'\n//           style={{ transform: `translate(${x}px, ${y}px)` }}\n//         />\n//       </div>\n//     </div>\n//   );\n// };\n// export default Dancing;","map":{"version":3,"names":["React","useState","useEffect","useRef","monkey_no_background_img","banana_img","GoBananas","jsx","_jsx","jsxs","_jsxs","useDebounce","callback","delay","timeoutRef","_len","arguments","length","args","Array","_key","clearTimeout","current","setTimeout","Dancing","monkey","setMonkey","x","y","monkeySpeed","driftDirection","setDriftDirection","xDirection","setXDirection","yDirection","setYDirection","injured","setInjured","injuredX","setInjuredX","injuredY","setInjuredY","bananas","setBananas","showBananas","setShowBananas","isAddingBanana","setIsAddingBanana","showClearButton","setShowClearButton","containerRef","animationFrameMonkeyRef","monkeyRef","bananaRef","animationFrameBananaRef","handleGoBananasClick","prevBananas","isSpinning","i","initialXDirection","Math","random","initialYDirection","window","innerWidth","innerHeight","handleClearBananasClick","addBanana","bananaStartX","width","bananaStartY","height","moveMonkey","containerWidth","clientWidth","containerHeight","clientHeight","monkeyWidth","monkeyHeight","prevPosition","newX","newY","newDriftDirection","max","min","requestAnimationFrame","cancelAnimationFrame","console","log","animateBananas","bananaWidth","bananaHeight","bananaSpeed","map","banana","resetInjured","addBananaWithDebounce","className","children","ref","onGoBananasClick","onClearBananasClick","index","src","alt","style","transform","concat","id","onClick"],"sources":["/home/pephlau/sloth/src/Dancing/Dancing.js"],"sourcesContent":["//Bouncing and More...\nimport React, { useState, useEffect, useRef } from 'react';\nimport './Dancing.css';\nimport monkey_no_background_img from '../Images/Space_Sloth_nbg.svg';\nimport banana_img from '../Images/note.webp';\nimport GoBananas from './GO_BANANAS';\n\n//Use debounce technique to handle double banana issue. Use it with new state const [isAddingBanana, setIsAddingBanana] = useState(false); \n//use debounce right before the return\n//debounce will also prevent banana-spaming aka \"going bananas\"\n\nconst useDebounce = (callback, delay) => {\n  //Create a reference to store the timer ID for the debounce\n  const timeoutRef = useRef(null);\n  //Return a new debounced function that wraps the original callback\n  return (...args) => {\n    //Clear the previous timer (if any) whenever the debounced function is called\n    clearTimeout(timeoutRef.current);\n    //Start a new timer using the setTimeout function\n    //The timer will execute the callback after the specified delay\n    timeoutRef.current = setTimeout(() => {\n      //Invoke the original callback with the provided arguments\n      callback(...args);\n    }, delay);\n  };\n};\n\nconst Dancing = () => {\n\n  //set states\n  const [monkey, setMonkey] = useState({ x: 100, y: 20 });\n  const monkeySpeed = .1\n  const [driftDirection, setDriftDirection] = useState({ x: 1, y: 1 });\n  const [xDirection, setXDirection] = useState(1);\n  const [yDirection, setYDirection] = useState(1);\n  const [injured, setInjured] = useState(false);\n  const [injuredX, setInjuredX] = useState(0);\n  const [injuredY, setInjuredY] = useState(0);\n  const [bananas, setBananas] = useState([]);\n  //Declare showBananas state\n  const [showBananas, setShowBananas] = useState(false); \n  //New state to track adding banana status\n  const [isAddingBanana, setIsAddingBanana] = useState(false); \n  //React handles state updates asynchronously. When the addBanana function is called, it updates the bananas state by appending a new banana to the existing array of bananas. However, if the state update for bananas is not completed before the next addBanana function is called, it can result in adding two bananas in quick succession.\n  //This can happen because React batches state updates to improve performance. If multiple state updates are triggered within the same event loop, React batches them together and performs the updates in one go. However, if the bananas state update from the first addBanana function is not yet complete when the next addBanana function is called, it will be using the old state of bananas, leading to the addition of two bananas.\n  //By introducing the isAddingBanana variable and the necessary checks, we can control the timing of adding bananas and ensure that a new banana is added only after the previous one has finished bouncing. This will prevent the issue of adding two bananas at a time.\n  //However, don't forget, even with this new state I will have to add the debounce technique.\n  //Go bananas\n  const [showClearButton, setShowClearButton] = useState(false);\n\n  const containerRef = useRef(null);\n  const animationFrameMonkeyRef = useRef(null);\n  const monkeyRef = useRef(null);\n  //Add bananaRef\n  const bananaRef = useRef(null);\n  //Add animationFrameBananaRef \n  const animationFrameBananaRef = useRef(null);\n\n  //GO BANANAS\n  const handleGoBananasClick = () => {\n    //Remove all the bananas and the monkey from the array\n    setBananas([]);\n    setShowBananas(false);\n\n    //Add the spinning monkey to the array\n    setBananas((prevBananas) => [\n      ...prevBananas,\n      {\n        x: 10, //Initial position of the spinning monkey\n        y: 200,\n        xDirection: 1,\n        yDirection: 1,\n        isSpinning: true, //Add a flag to identify the spinning monkey\n      },\n    ]);\n\n    //Generate 100 bouncing bananas and add them to the array\n    for (let i = 0; i < 100; i++) {\n      const initialXDirection = Math.random() < 0.5 ? 1 : -1;\n      const initialYDirection = Math.random() < 0.5 ? 1 : -1;\n      setBananas((prevBananas) => [\n        ...prevBananas,\n        {\n          x: Math.random() * window.innerWidth,\n          y: Math.random() * window.innerHeight,\n          xDirection: initialXDirection,\n          yDirection: initialYDirection,\n        },\n      ]);\n    }\n    setShowBananas(true);\n    setShowClearButton(true); // Show the \"Clear Bananas\" button after generating bananas\n  \n\n    // Update the \"showBananas\" state to true\n    setShowBananas(true);\n  };\n\n  //clear banana madness\n  const handleClearBananasClick = () => {\n    setBananas([]);\n    setShowBananas(false);\n    //Set showClearButton to false after clearing the bananas\n    setShowClearButton(false);\n  };\n\n  //add banana\n  const addBanana = (x, y) => {\n    if (!isAddingBanana && bananas.length < 100) {\n      // Generate random initial direction for the banana\n      const initialXDirection = Math.random() < 0.5 ? 1 : -1;\n      const initialYDirection = Math.random() < 0.5 ? 1 : -1;\n\n      //set the starting position of the banana relative to the monkey\n      //Half of the monkey's width\n      const bananaStartX = x + monkeyRef.current.width / 4;\n      //Half of the monkey's height\n      //Does this look good at all sizes? \n      const bananaStartY = y + monkeyRef.current.height / 2; \n\n      setBananas((prevBananas) => [\n        ...prevBananas,\n        {\n          x: bananaStartX,\n          y: bananaStartY,\n          xDirection: initialXDirection,\n          yDirection: initialYDirection,\n        },\n      ]);\n      setShowBananas(true);\n    }\n  };\n\n  //animate monkey\n  useEffect(() => {\n      const moveMonkey = () => {\n          const containerWidth = containerRef.current.clientWidth;\n          const containerHeight = containerRef.current.clientHeight;\n          const monkeyWidth = monkeyRef.current.width;\n          const monkeyHeight = monkeyRef.current.height;\n          \n          setMonkey((prevPosition) => {\n              let newX = prevPosition.x + driftDirection.x * monkeySpeed;\n              let newY = prevPosition.y + driftDirection.y * monkeySpeed;\n\n              let newDriftDirection = { ...driftDirection };\n\n              if (newX >= containerWidth - monkeyWidth || newX <= 0) {\n                  newDriftDirection.x *= -1; // Reverse X direction\n                  newX = Math.max(0, Math.min(containerWidth - monkeyWidth, newX));\n              }\n              if (newY >= containerHeight - monkeyHeight || newY <= 0) {\n                  newDriftDirection.y *= -1; // Reverse Y direction\n                  newY = Math.max(0, Math.min(containerHeight - monkeyHeight, newY));\n              }\n\n              setDriftDirection(newDriftDirection); // Update the drift direction\n\n              return { x: newX, y: newY };\n          });\n\n          animationFrameMonkeyRef.current = requestAnimationFrame(moveMonkey);\n      };\n\n      animationFrameMonkeyRef.current = requestAnimationFrame(moveMonkey);\n\n      return () => cancelAnimationFrame(animationFrameMonkeyRef.current);\n  }, [driftDirection, monkeySpeed, setMonkey, containerRef]);\n\n  \n\n\n  //animate banana\n  useEffect(() => {\n    //console.log for bananas array\n    console.log(\"Bananas:\", bananas);\n    const animateBananas = () => {\n      const containerWidth = containerRef.current.clientWidth;\n      const containerHeight = containerRef.current.clientHeight;\n      const bananaWidth = bananaRef.current.width;\n      const bananaHeight = bananaRef.current.height;\n      const bananaSpeed = .2;\n\n      setBananas((prevBananas) =>\n        prevBananas.map((banana) => ({\n          ...banana,\n          x: banana.x + banana.xDirection * bananaSpeed,\n          y: banana.y + banana.yDirection * bananaSpeed,\n          xDirection:\n            banana.x + banana.xDirection * bananaSpeed >= containerWidth - bananaWidth ||\n            banana.x + banana.xDirection * bananaSpeed <= 0\n              ? banana.xDirection * -1\n              : banana.xDirection,\n          yDirection:\n            banana.y + banana.yDirection * bananaSpeed >= containerHeight - bananaHeight ||\n            banana.y + banana.yDirection * bananaSpeed <= 0\n              ? banana.yDirection * -1\n              : banana.yDirection,\n        }))\n      );\n\n      animationFrameBananaRef.current = requestAnimationFrame(animateBananas);\n    };\n\n    if (showBananas && bananas.length > 0) {\n      animationFrameBananaRef.current = requestAnimationFrame(animateBananas);\n    }\n\n    return () => cancelAnimationFrame(animationFrameBananaRef.current);\n  }, [showBananas, bananas]);\n\n  //is injured? drop banana\n  useEffect(() => {\n    //console.log for isAddingBanana state\n    console.log(\"Is Adding Banana:\", isAddingBanana);\n    if (injured) {\n      setShowBananas(true); \n  \n      const resetInjured = setTimeout(() => {\n        setInjured(false);\n        //Reset adding banana status \n        setIsAddingBanana(false);\n        //Add banana near the monkey when it gets injured \n        addBanana(injuredX, injuredY);\n        //Delay in milliseconds before resetting injured state \n      }, 500); \n  \n      return () => clearTimeout(resetInjured);\n    } else {\n      //Reset adding banana status when the monkey is not injured\n      setIsAddingBanana(false); \n    }\n  }, [injured, injuredX, injuredY]);\n\n  //debounce to use later\n  const addBananaWithDebounce = useDebounce(addBanana, 500);\n\n  return (\n    <div className='page_body'>\n      <div className='dancing_monkey_container' ref={containerRef}>\n        <GoBananas\n          onGoBananasClick={handleGoBananasClick}\n          showClearButton={showClearButton}\n          onClearBananasClick={handleClearBananasClick}\n        />\n        {showBananas &&\n          bananas.map((banana, index) => (\n            <img\n              key={index}\n              src={banana_img}\n              alt='banana'\n              className='banana_img'\n              style={{ transform: `translate(${banana.x}px, ${banana.y}px)` }}\n              ref={bananaRef}\n            />\n          ))}\n        <img\n          ref={monkeyRef}\n          src={monkey_no_background_img}\n          alt='dancing_monkey'\n          id='dancing_monkey_img'\n          className={injured ? 'injured_monkey' : ''}\n          style={{ transform: `translate(${monkey.x}px, ${monkey.y}px)` }}\n          onClick={() => {\n            if (bananas.length < 10 && !isAddingBanana) {\n              setInjured(true);\n              setInjuredX(monkey.x);\n              setInjuredY(monkey.y);\n              setIsAddingBanana(true);\n              addBananaWithDebounce(monkey.x, monkey.y);\n            }\n          }}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default Dancing;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// //Monkey is bouncing and only bouncing\n// import React, { useState, useEffect, useRef } from 'react';\n// import './Dancing.css';\n// import monkey_no_background_img from '../../images/Space_Monkey_No_Background.svg';\n\n// const Dancing = () => {\n//   const [x, setX] = useState(10);\n//   const [y, setY] = useState(200);\n//   const [xDirection, setXDirection] = useState(1);\n//   const [yDirection, setYDirection] = useState(1);\n\n//   const imageRef = useRef(null);\n//   const containerRef = useRef(null);\n//   const animationFrameRef = useRef(null);\n\n//   useEffect(() => {\n//     const animate = () => {\n//       const containerWidth = containerRef.current.clientWidth;\n//       const containerHeight = containerRef.current.clientHeight;\n//       const monkeyWidth = imageRef.current.width;\n//       const monkeyHeight = imageRef.current.height;\n//       const speed = .4; \n\n//       console.log('x:', x);\n//       console.log('y:', y);\n//       console.log('xDirection:', xDirection);\n//       console.log('yDirection:', yDirection);\n\n//       setX((prevX) => {\n//         const nextX = prevX + xDirection * speed;\n//         if (nextX >= containerWidth - monkeyWidth || nextX <= 0) {\n//           setXDirection((prevDirection) => prevDirection * -1);\n//         }\n//         return nextX;\n//       });\n\n//       setY((prevY) => {\n//         const nextY = prevY + yDirection * speed;\n//         if (nextY >= containerHeight - monkeyHeight || nextY <= 0) {\n//           setYDirection((prevDirection) => prevDirection * -1);\n//         }\n//         return nextY;\n//       });\n\n//       animationFrameRef.current = requestAnimationFrame(animate);\n//     };\n\n//     // Start the animation loop on mount\n//     animationFrameRef.current = requestAnimationFrame(animate);\n\n//     // Clean up the animation frame when unmount\n//     return () => cancelAnimationFrame(animationFrameRef.current);\n//   }, [x, y, xDirection, yDirection]);\n\n//   return (\n//     <div className='page_body'>\n//       <div className='dancing_monkey_container' ref={containerRef}>\n//         <img\n//           ref={imageRef}\n//           src={monkey_no_background_img}\n//           alt='dancing_monkey'\n//           id='dancing_monkey_img'\n//           style={{ transform: `translate(${x}px, ${y}px)` }}\n//         />\n//       </div>\n//     </div>\n//   );\n// };\n\n// export default Dancing;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//Monkey is Bouncing\n// import React, { useState, useEffect, useRef } from 'react';\n// import './Dancing.css';\n// import monkey_no_background_img from '../../images/Space_Monkey_No_Background.svg';\n\n// const Dancing = () => {\n//   const [x, setX] = useState(0);\n//   const [y, setY] = useState(0);\n//   const [xDirection, setXDirection] = useState(1);\n//   const [yDirection, setYDirection] = useState(1);\n\n//   const imageRef = useRef(null);\n//   const containerRef = useRef(null);\n//   const animationFrameRef = useRef(null);\n\n//   useEffect(() => {\n//     const animate = () => {\n//       const containerWidth = containerRef.current.clientWidth;\n//       const containerHeight = containerRef.current.clientHeight;\n//       const monkeyWidth = imageRef.current.width;\n//       const monkeyHeight = imageRef.current.height;\n//       const speed = 2; // Adjust the speed for smoother motion\n\n//       console.log('x:', x);\n//       console.log('y:', y);\n//       console.log('xDirection:', xDirection);\n//       console.log('yDirection:', yDirection);\n\n//       setX((prevX) => {\n//         const nextX = prevX + xDirection * speed;\n//         if (nextX >= containerWidth - monkeyWidth || nextX <= 0) {\n//           setXDirection((prevDirection) => prevDirection * -1);\n//         }\n//         return nextX;\n//       });\n\n//       setY((prevY) => {\n//         const nextY = prevY + yDirection * speed;\n//         if (nextY >= containerHeight - monkeyHeight || nextY <= 0) {\n//           setYDirection((prevDirection) => prevDirection * -1);\n//         }\n//         return nextY;\n//       });\n\n//       animationFrameRef.current = requestAnimationFrame(animate);\n//     };\n\n//     // Start the animation loop on mount\n//     animationFrameRef.current = requestAnimationFrame(animate);\n\n//     // Clean up the animation frame when unmount\n//     return () => cancelAnimationFrame(animationFrameRef.current);\n//   }, [x, y, xDirection, yDirection]);\n\n//   return (\n//     <div className='page_body'>\n//       <div className='dancing_monkey_container' ref={containerRef}>\n//         <img\n//           ref={imageRef}\n//           src={monkey_no_background_img}\n//           alt='dancing_monkey'\n//           id='dancing_monkey_img'\n//           style={{ transform: `translate(${x}px, ${y}px)` }}\n//         />\n//       </div>\n//     </div>\n//   );\n// };\n\n// export default Dancing;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// ok, now the monkeytravels to the bottom of the container...then, he moves to the right util he exists the container and disappears...please fix that so that the monkey bounces around the container.\n\n// import React, { useState, useEffect, useRef } from 'react';\n// import './Dancing.css';\n// import monkey_no_background_img from '../images/Space_Monkey_No_Background.png';\n\n// const Dancing = () => {\n//   const [x, setX] = useState(0);\n//   const [y, setY] = useState(0);\n//   const [xDirection, setXDirection] = useState(1);\n//   const [yDirection, setYDirection] = useState(1);\n\n//   const imageRef = useRef(null);\n//   const containerRef = useRef(null);\n\n//   useEffect(() => {\n//     const animate = () => {\n//       const containerWidth = containerRef.current.clientWidth;\n//       const containerHeight = containerRef.current.clientHeight;\n//       const monkeyWidth = imageRef.current.width;\n//       const monkeyHeight = imageRef.current.height;\n//       const speed = 1.5; // Adjust the speed for smoother motion\n\n//       setX((prevX) => {\n//         const nextX = prevX + xDirection * speed;\n//         if (nextX >= containerWidth - monkeyWidth || nextX <= 0) {\n//           setXDirection((prevDirection) => prevDirection * -1);\n//         }\n//         return nextX;\n//       });\n\n//       setY((prevY) => {\n//         const nextY = prevY + yDirection * speed;\n//         if (nextY >= containerHeight - monkeyHeight || nextY <= 0) {\n//           setYDirection((prevDirection) => prevDirection * -1);\n//         }\n//         return nextY;\n//       });\n\n//       requestAnimationFrame(animate);\n//     };\n\n//     // Start the animation loop when the component mounts\n//     const animationFrame = requestAnimationFrame(animate);\n\n//     // Clean up the animation frame when the component unmounts\n//     return () => cancelAnimationFrame(animationFrame);\n//   }, [xDirection, yDirection]);\n\n//   return (\n//     <div className='page_body'>\n//       <div className='dancing_monkey_container' ref={containerRef}>\n//         <img\n//           ref={imageRef}\n//           src={monkey_no_background_img}\n//           alt='dancing_monkey'\n//           id='dancing_monkey_img'\n//           style={{ transform: `translate(${x}px, ${y}px)` }}\n//         />\n//       </div>\n//     </div>\n//   );\n// };\n\n// export default Dancing;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// One direction animation\n// import React, { useEffect, useState, useRef } from 'react';\n// import './Dancing.css';\n// import monkey_no_background_img from '../images/Space_Monkey_No_Background.png';\n\n// const Dancing = () => {\n//   const [x, setX] = useState(0);\n//   const [y, setY] = useState(0);\n//   const [xDirection, setXDirection] = useState(1);\n//   const [yDirection, setYDirection] = useState(1);\n\n//   const imageRef = useRef(null);\n\n//   const containerRef = useRef(null); // Reference to the container element\n\n//   const animate = () => {\n//     const containerWidth = containerRef.current.clientWidth;\n//     const containerHeight = containerRef.current.clientHeight;\n//     const monkeyWidth = imageRef.current.width;\n//     const monkeyHeight = imageRef.current.height;\n//     const speed = 1.5; // Adjust the speed for smoother motion\n//     const damping = 0.8; // Adjust the damping for smoother bouncing\n  \n//     setX((prevX) => {\n//       let nextX = prevX + xDirection * speed;\n//       if (nextX >= containerWidth - monkeyWidth || nextX <= 0) {\n//         setXDirection((prevDirection) => prevDirection * -1 * damping);\n//         nextX = prevX + xDirection * speed * damping;\n//       }\n//       return Math.max(0, Math.min(nextX, containerWidth - monkeyWidth));\n//     });\n  \n//     setY((prevY) => {\n//       let nextY = prevY + yDirection * speed;\n//       if (nextY >= containerHeight - monkeyHeight || nextY <= 0) {\n//         setYDirection((prevDirection) => prevDirection * -1 * damping);\n//         nextY = prevY + yDirection * speed * damping;\n//       }\n//       return Math.max(0, Math.min(nextY, containerHeight - monkeyHeight));\n//     });\n    \n//     requestAnimationFrame(animate);\n//   };\n\n//   // Start the animation loop when the component mounts\n//   useEffect(() => {\n//     requestAnimationFrame(animate);\n//   }, []);\n\n//   return (\n//     <div className='page_body'>\n//       <div className='dancing_monkey_container' ref={containerRef}>\n//         <img\n//           ref={imageRef}\n//           src={monkey_no_background_img}\n//           alt='dancing_monkey'\n//           id='dancing_monkey_img'\n//           style={{ transform: `translate(${x}px, ${y}px)` }}\n//         />\n//       </div>\n//     </div>\n//   );\n// };\n\n// export default Dancing;\n"],"mappings":"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CA;AACA;AACA;AACA;AAEA;AAkDA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA8BA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA4CA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}